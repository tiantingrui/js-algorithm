# 贪心算法

#### 贪心算法是什么？
+ 贪心算法是**算法设计**中的一种方法。一种思想
+ 期盼通过每个阶段的**局部最优**选择，从而达到全局的最优
+ 结果并**不一定是最优**

可以理解为是动态规划的一个特例，贪心还需要满足一个特征”贪心选择性质“
+ 贪心选择性质：每一步做出的一个局部最优的选择，最终的结果就是全局最优

#### 场景一：零钱兑换
```
输入： coins = [1, 2, 5], amount = 11
输出：3
解释： 11 = 5 + 5 + 1

输入： coins = [1, 3, 4], amount = 6
输出：3
解释： 6 = 4 + 1 + 1
```

一个负面例子：天龙八部-珍珠棋局


#### leetcode 练习题目
- [ ] lc455 分饼干 easy
- [ ] lc122 买卖股票的最佳时机 easy

## 区间调度问题
有很多 [start, end] 的闭区间，请设计一个算法，算出这些区间中，最多有几个互不相交的区间！
[8, 12] [9, 11] [13, 14]....
#### 贪心求解
1. 我们是否可以每次都选择区间中开始最早的那个？ 
   [0, 15][1,2][2,3][5,6] 
2. 我们都选择持续时间最短的？
   [1, 3] [2, 4]  
#### 正确思路
1. 从可选的区间里，选择一个结束 end最小的区间 x
2. 把所有和 x 相交的区间 从 sum 中剔除掉
3. 重复一二的循环，之前选出的各种区间 x 就是我们所求的结果


## 区间调度算法的应用
1. 无重叠区间
给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠？
[1, 2] [2, 3] 的边界相互触碰，但是不算做相互重叠
比如：输入 [1, 2] [2, 3] [3, 4] [1,3]
输出： 1
解释：因为 移除 [1, 3]后，剩下的区间互不重叠


```js
const intervalSchedule = (intvs) => {
  if (intvs.length) return 0;

  const sortArray = intvs.sort((a, b) => a[1] - b[1]);  // 根据 end 升序排序
  let xEnd = sortArray[0][1];
  let count = 1; // 互不相交的区间 

  for (item of intvs) {
    const start = item[0]

    if (start >= xEnd) {
      count ++ 
      xEnd = item[1]
    }
  }
  return intvs.length - count
}
```
 
2. 用最少的箭头射爆气球
01:47:20

